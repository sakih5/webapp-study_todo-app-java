# 実践から学ぶ要件定義の思考プロセス - Todoアプリを例に

## 本記事を作成した背景

ソフトウェア開発において、要件定義は最も重要なフェーズの一つです。しかし、「どうやってユーザーの要求を引き出すのか」「どう整理すれば漏れのない要件になるのか」という具体的なプロセスは、教科書には書かれていても、実際の思考プロセスまで言語化されることは少ないです。

今回、実際にTodoアプリの要件定義を行う過程で、どのような質問をして、どう考えて、どう整理したかを記録として残すことにしました。この記事が、これから要件定義に取り組む方の参考になれば幸いです。

## 本記事で取り組んだこと

- ユーザーへの段階的な質問を通じた要求の引き出し
- 技術的制約と機能要求のバランス調整
- MVP（最小限の機能）から段階的な拡張を見据えた要件整理
- データモデルとAPI設計への落とし込み
- 実際の要件定義書の作成

## 手順

### 前提

- **目的**: Todoアプリの要件定義を行う
- **前提知識**: Web開発の基本的な知識（フロントエンド、バックエンド、データベースの概念）
- **使用技術**: HTML/JavaScript（フロントエンド）、Spring Boot（バックエンド）、PostgreSQL（データベース）

### 1. 基本方針の決定 - プラットフォームとアーキテクチャ

#### 🎯 目的

要件定義の最初に、技術的な大枠を決めます。これにより、後の議論で「技術的に実現可能か」を判断する基準ができます。

#### 🛠️ 手順詳細

最初に以下の4つの質問をしました：

1. **プラットフォーム**: どこで動かすか？
   - Webアプリケーション / モバイルアプリ / デスクトップアプリ

2. **ユーザー認証**: 誰が使うか？
   - マルチユーザー対応 / シングルユーザー

3. **データ保存**: データをどこに保存するか？
   - ローカルストレージ / データベース/バックエンド

4. **機能範囲**: どこまで作るか？
   - 最小限 / 標準的 / 高機能

**回答結果**:

- Webアプリケーション
- マルチユーザー対応（ログイン機能必要）
- データベース/バックエンド
- 機能範囲は「最初は最小限で、ゆくゆくは高機能化できるようにしていきたい」

#### 💡 理解ポイント

**なぜこの順番で質問するのか？**

1. **プラットフォーム**: 技術スタックの選択肢が決まる
   - Webなら HTML/CSS/JS、モバイルなら React Native/Flutter など

2. **認証の有無**: データモデルとセキュリティ要件が変わる
   - マルチユーザーなら User テーブル、認証ロジック、権限管理が必要
   - シングルユーザーならそれらが不要

3. **データ保存方法**: システムアーキテクチャが決まる
   - ローカルストレージ → フロントエンドのみで完結
   - データベース → バックエンドAPIが必要

4. **機能範囲**: 開発スコープと優先順位の方針が決まる

**思考のポイント**:

- この段階では「何を作るか」ではなく「どういうシステムにするか」の骨格を決める
- 後戻りしにくい技術的な意思決定を先に固める
- ユーザーが「対話的に決めたい」と言った場合は、柔軟に次のステップへ

#### 📝 補足

もし「技術スタックはおまかせ」と言われた場合は、こちらから推奨を提示します。ただし今回は「希望あり」とのことだったので、さらに深掘りしました。

```
Q: どのような技術を希望されますか？
A: フロントエンドはHTML+JavaScript、バックエンドはSpring Boot、DBはPostgreSQL
```

この時点で技術スタックが確定し、以降の設計はこれを前提に進めます。

### 2. コアデータの定義 - Todoが持つべき属性

#### 🎯 目的

「Todo」という概念を具体化します。どんな情報を持つべきかを決めることで、データベース設計の基礎が固まります。

#### 🛠️ 手順詳細

次の質問を複数選択可能な形式で投げかけました：

**質問**: 「Todoの基本情報としてどのような項目が必要ですか？」

選択肢：

- タスク名（必須）
- 期限日
- 優先度
- カテゴリー/プロジェクト

**回答結果**:
全て選択 + 追加で「タスクの説明」

#### 💡 理解ポイント

**なぜ「選択肢 + その他」形式にするのか？**

1. **選択肢の提示**: よくある属性を提示することで、ユーザーの思考を助ける
   - 白紙から「何が必要？」と聞かれると答えにくい
   - 「これは？これは？」と聞かれると判断しやすい

2. **その他入力の許可**: 選択肢にない要求も拾える
   - 今回は「タスクの説明」が追加された
   - ユーザー独自のニーズを取りこぼさない

**データモデル設計への影響**:

選ばれた属性から、Todoテーブルの構造が見えてきます：

```
Todo:
  - title (タスク名) → String, NOT NULL
  - description (説明) → Text, NULLABLE
  - due_date (期限日) → DateTime, NULLABLE
  - priority (優先度) → Enum, NOT NULL
  - category_id (カテゴリー) → Foreign Key, NULLABLE
```

**思考のポイント**:

- 「必須」と「任意」を意識する
  - タスク名は必ず必要 → NOT NULL
  - 期限日は設定しないこともある → NULLABLE

- カテゴリーは別テーブルに分離
  - 複数のTodoで同じカテゴリーを使うため
  - カテゴリーマスタを管理する必要がある

#### 📝 補足

この段階で「サブタスク」や「タグ」は出てきませんでした。これらは後の「追加機能」で聞くため、ここでは基本属性に絞ります。

### 3. 機能要件の洗い出し - 何ができる必要があるか

#### 🎯 目的

データが決まったので、次は「そのデータをどう操作するか」を明確にします。CRUD操作だけでなく、検索、フィルタリング、可視化など、ユーザーが本当に必要とする機能を引き出します。

#### 🛠️ 手順詳細

3つの質問を段階的に投げかけました：

**質問1**: 「Todoの表示・操作機能として必要なものは？」（複数選択可）

選択肢：

- 一覧表示
- フィルタリング
- ソート機能
- 検索機能

**回答**: 全て選択 + 追加で「可視化機能：1日何にどれくらい時間を使ったかがわかる」

**質問2**: 「その他の機能として実装したいものは？」（複数選択可）

選択肢：

- サブタスク
- タグ付け
- 繰り返しタスク
- 通知機能

**回答**: 全て選択 + 追加で「1日の過ごし方を振り返ることができる」

**質問3**: 「開発の優先順位は？」（単一選択）

選択肢：

- MVP最優先 - 最小限の機能で動くものをまず作る
- バランス型 - 基本機能をしっかり作り込んでから応用機能へ
- フル実装 - 最初から全ての機能を実装する

**回答**: MVP最優先

#### 💡 理解ポイント

**なぜ3段階に分けるのか？**

1. **基本操作**: どんなアプリでも必要な最低限の機能
   - 一覧、検索、ソート、フィルタリング
   - これがないと使い物にならない

2. **付加価値機能**: アプリの特徴を作る機能
   - サブタスク、タグ、繰り返し、通知
   - あると便利だが、MVPには必須ではない

3. **開発方針**: どう作るかの戦略
   - MVP最優先 → 段階的リリース、早期フィードバック
   - バランス型 → 品質重視、一定の完成度を持ってリリース
   - フル実装 → 全機能揃えてからリリース

**重要な追加要求の発見**:

今回、ユーザーから2つの重要な追加要求が出ました：

1. 「1日何にどれくらい時間を使ったかがわかる」（可視化）
2. 「1日の過ごし方を振り返ることができる」（振り返り）

これらは選択肢にない独自の要求であり、このアプリの核心的な価値提案になります。

**思考のポイント**:

- 選択肢は「よくある機能」を提示し、判断を助ける
- しかし真の価値は「その他」で出てくる独自要求にあることが多い
- 「その他」で出た内容は、次の質問で深掘りする

#### 📝 補足

もし「MVP最優先」が選ばれなかった場合、開発期間や難易度について説明し、再考を促すこともあります。特に個人開発や学習目的の場合、スコープの絞り込みは重要です。

### 4. 特殊要件の深掘り - 時間トラッキングと可視化

#### 🎯 目的

ステップ3で出てきた「時間管理」「可視化」という独自要求を具体化します。曖昧な要求を、実装可能なレベルまで落とし込みます。

#### 🛠️ 手順詳細

2つの深掘り質問を行いました：

**質問1**: 「時間トラッキングの方法は？」（複数選択可）

選択肢：

- タイマー機能（自動記録）
- 手動入力（後から入力）
- 予定時間の設定（計画と実績の比較）

**回答**: 手動入力 + 予定時間の設定

**質問2**: 「可視化・振り返り機能では何を表示したい？」（複数選択可）

選択肢：

- 日別の時間分布
- カテゴリー別集計
- 週/月単位の統計
- タスク完了率

**回答**: 全て選択 + 追加で「24時間の過ごし方が積み上げ棒グラフで見れる（時系列順とカテゴリ別で集計したものそれぞれ切り替えて）」

#### 💡 理解ポイント

**なぜ深掘りするのか？**

最初の回答「1日何にどれくらい時間を使ったかがわかる」だけでは、具体的な実装イメージが湧きません。

- どうやって時間を記録する？ → タイマー？ 手動入力？
- どう表示する？ → グラフ？ テーブル？
- どの期間を見る？ → 日単位？ 週単位？ 月単位？

これらを明確にすることで、データモデルとAPI設計が決まります。

**データモデルへの影響**:

時間トラッキングの要件から、新しいテーブルが必要だとわかります：

```
TimeEntry (時間記録):
  - id
  - todo_id (どのTodoの作業か)
  - duration (何分かかったか)
  - start_time (いつからいつまで作業したか)
  - end_time
  - note (メモ)
  - created_at
```

**API設計への影響**:

可視化機能の要件から、必要なAPIエンドポイントが見えてきます：

```
GET /api/stats/daily?date=2025-12-14
  → 指定日の時間分布を返す

GET /api/stats/timeline?date=2025-12-14&view=timeline
  → 24時間の積み上げ棒グラフデータ（時系列順）

GET /api/stats/timeline?date=2025-12-14&view=category
  → 24時間の積み上げ棒グラフデータ（カテゴリー別集計）
```

**思考のプロセス**:

1. 曖昧な要求「可視化したい」
2. ↓ 質問「何を？どう？」
3. 具体的な要求「24時間の積み上げ棒グラフで、時系列とカテゴリー別を切り替え」
4. ↓ 技術的検討
5. データ構造とAPI設計

#### 📝 補足

**タイマー機能を選ばなかった理由**:

ユーザーが「手動入力」を選んだ背景には、おそらく以下の考えがあります：

- リアルタイムで記録するのは面倒
- 後でまとめて記録したい
- タイマーのスタート/ストップを忘れることがある

これは「ユーザーの利用シーン」を示しているため、UI設計に活かせます。例えば：

- Todo完了時に「何分かかりましたか？」と聞く
- よく使う時間（15分、30分、1時間）をワンクリックで入力できるようにする

### 5. 要件の構造化と優先順位付け

#### 🎯 目的

洗い出した全ての要件を整理し、段階的に実装できる形に構造化します。

#### 🛠️ 手順詳細

収集した要件を、以下の3つのフェーズに分類しました：

**Phase 1: MVP (Minimum Viable Product)**

- ユーザー認証（登録、ログイン、ログアウト）
- 基本的なTodo管理（作成、編集、削除、完了/未完了）
- 基本UI

必要最小限で「動くTodoアプリ」を実現します。

**Phase 2: 時間管理機能**

- 時間トラッキング（予定時間、実績時間の手動入力）
- フィルタリング、ソート、検索
- 基本的な可視化（日別、カテゴリー別）

アプリの核心価値である「時間管理」を実装します。

**Phase 3: 高度な機能**

- サブタスク
- タグ機能
- 繰り返しタスク
- 通知機能
- 高度な可視化（24時間積み上げグラフ、週/月統計）

あると便利な付加価値機能を追加します。

#### 💡 理解ポイント

**なぜ3段階に分けるのか？**

1. **リスク低減**: 早い段階で動くものを作り、技術的な問題を発見
2. **早期フィードバック**: Phase 1で実際に使ってもらい、要件の妥当性を確認
3. **モチベーション維持**: 完成品を見ることで、開発のモチベーションが上がる
4. **柔軟性**: Phase 1の結果を受けて、Phase 2以降の内容を調整できる

**優先順位の決め方**:

```
Phase 1: なければ動かない機能
  → 認証、CRUD、基本UI

Phase 2: アプリの核心価値を提供する機能
  → 時間トラッキング、可視化

Phase 3: あると便利だが、なくても使える機能
  → サブタスク、タグ、繰り返し
```

**思考のポイント**:

- 「なければ成立しない」か「あると便利」かで判断
- ユーザーが強調した機能（時間管理）は Phase 2 に
- 技術的に複雑な機能（繰り返しタスクの自動生成）は Phase 3 に

#### 📝 補足

フェーズ分けは絶対的なものではありません。開発途中でユーザーから「やっぱりタグ機能を先に」と言われたら、柔軟に調整します。

### 6. データモデル設計 - 要件をデータベース構造に落とし込む

#### 🎯 目的

洗い出した要件を、具体的なデータベーステーブル設計に落とし込みます。

#### 🛠️ 手順詳細

要件から必要なテーブルを抽出しました：

**Phase 1で必要なテーブル**:

1. **User（ユーザー）**
   - なぜ必要？ → マルチユーザー対応のため
   - 属性: id, email, password_hash, username, created_at, updated_at

2. **Category（カテゴリー）**
   - なぜ必要？ → Todoをカテゴリー分けするため
   - 属性: id, user_id, name, color, created_at, updated_at
   - リレーション: User に属する（1対多）

3. **Todo（タスク）**
   - なぜ必要？ → アプリの中心的なデータ
   - 属性: id, user_id, category_id, title, description, priority, due_date, estimated_time, is_completed, completed_at, created_at, updated_at
   - リレーション: User に属する、Category に属する（任意）

**Phase 2で追加するテーブル**:

4. **TimeEntry（時間記録）**
   - なぜ必要？ → 時間トラッキング機能のため
   - 属性: id, todo_id, duration, start_time, end_time, note, created_at
   - リレーション: Todo に属する（1対多）

**Phase 3で追加するテーブル**:

5. **Tag（タグ）**
   - なぜ必要？ → タグ機能のため
   - 属性: id, user_id, name, created_at

6. **TodoTag（中間テーブル）**
   - なぜ必要？ → TodoとTagは多対多の関係
   - 属性: todo_id, tag_id

#### 💡 理解ポイント

**要件からテーブルを導く思考プロセス**:

1. **名詞を探す**
   - 「ユーザーが」「Todoを」「カテゴリーで」「タグを付けて」
   - → User, Todo, Category, Tag

2. **動詞を探す**
   - 「時間を記録する」
   - → TimeEntry（記録の実体化）

3. **関係性を考える**
   - 「Todoはユーザーに属する」 → user_id (Foreign Key)
   - 「Todoはカテゴリーに属する（任意）」 → category_id (Nullable)
   - 「TodoとTagは多対多」 → 中間テーブル TodoTag

4. **制約を考える**
   - 「タスク名は必須」 → title NOT NULL
   - 「期限日は任意」 → due_date NULLABLE
   - 「メールアドレスは重複不可」 → email UNIQUE

**サブタスクの設計**:

要件に「サブタスク」がありました。これは自己参照（self-reference）で実現します：

```
Todo:
  - parent_todo_id (Foreign Key -> Todo, Nullable)
```

親タスクの場合、parent_todo_id は NULL。
サブタスクの場合、parent_todo_id に親のIDを入れる。

**思考のポイント**:

- 「物」と「物の関係」を分けて考える
- 1対多、多対多を見極める
- 将来の拡張を見据えた柔軟性を持たせる（例: カテゴリーのcolor属性）

#### 📝 補足

**正規化のバランス**:

理論的には第3正規形まで正規化すべきですが、実用上はパフォーマンスとのトレードオフを考えます。

例えば、Todoテーブルに `is_completed` と `completed_at` の両方を持つのは冗長ですが、クエリの高速化のために許容しています。

```sql
-- is_completedがあれば completed_atの有無で判断できるが...
SELECT * FROM todos WHERE is_completed = true;

-- この方が高速（インデックスが効く）
SELECT * FROM todos WHERE is_completed = true;

-- こちらはインデックスが効きにくい
SELECT * FROM todos WHERE completed_at IS NOT NULL;
```

### 7. API設計 - フロントエンドとバックエンドの契約

#### 🎯 目的

データモデルが決まったので、「どうやってそのデータにアクセスするか」を定義します。RESTful APIの設計を行います。

#### 🛠️ 手順詳細

リソースごとにエンドポイントを設計しました：

**認証API**:

```
POST   /api/auth/register    # ユーザー登録
POST   /api/auth/login       # ログイン（JWTトークン発行）
POST   /api/auth/logout      # ログアウト
GET    /api/auth/me          # 現在のユーザー情報取得
```

**Todo API**:

```
GET    /api/todos              # Todo一覧（クエリパラメータでフィルタ・ソート）
POST   /api/todos              # Todo作成
GET    /api/todos/{id}         # Todo詳細取得
PUT    /api/todos/{id}         # Todo更新
DELETE /api/todos/{id}         # Todo削除
PATCH  /api/todos/{id}/complete # 完了/未完了切り替え
```

**クエリパラメータの例**:

```
GET /api/todos?status=incomplete&category=work&sort=due_date&order=asc
  → 未完了で、カテゴリーが「仕事」のTodoを期限日昇順で取得
```

**カテゴリーAPI**:

```
GET    /api/categories         # カテゴリー一覧
POST   /api/categories         # カテゴリー作成
PUT    /api/categories/{id}    # カテゴリー更新
DELETE /api/categories/{id}    # カテゴリー削除
```

**時間記録API（Phase 2）**:

```
POST   /api/todos/{id}/time-entries    # 時間記録追加
GET    /api/todos/{id}/time-entries    # 特定Todoの時間記録一覧
PUT    /api/time-entries/{id}          # 時間記録更新
DELETE /api/time-entries/{id}          # 時間記録削除
```

**統計・可視化API（Phase 2-3）**:

```
GET /api/stats/daily?date=2025-12-14
GET /api/stats/weekly?start_date=2025-12-08
GET /api/stats/monthly?year=2025&month=12
GET /api/stats/timeline?date=2025-12-14&view=timeline
GET /api/stats/timeline?date=2025-12-14&view=category
GET /api/stats/category?start_date=2025-12-01&end_date=2025-12-31
```

#### 💡 理解ポイント

**RESTful設計の原則**:

1. **リソース指向**: URLはリソースを表す（動詞ではなく名詞）
   - ❌ `/api/getTodos`
   - ✅ `/api/todos` (GET)

2. **HTTPメソッドで操作を表現**:
   - GET: 取得
   - POST: 作成
   - PUT: 全体更新
   - PATCH: 部分更新
   - DELETE: 削除

3. **ネストの使い分け**:
   - `/api/todos/{id}/time-entries` → 「特定Todoの時間記録」を表現
   - `/api/time-entries/{id}` → 「時間記録そのもの」を操作

**なぜ `/api/todos/{id}/complete` は PATCH なのか？**

```
PATCH /api/todos/{id}/complete
```

これは「Todoの一部（is_completedフィールド）だけを更新する」という意味です。

もし PUT を使うと、全フィールドを送る必要があります：

```json
// PUT の場合（全フィールド送信）
PUT /api/todos/{id}
{
  "title": "買い物に行く",
  "description": "牛乳とパンを買う",
  "due_date": "2025-12-15",
  "priority": "medium",
  "category_id": "xxx",
  "is_completed": true  // これだけ変えたいのに...
}

// PATCH の場合（変更したいフィールドのみ）
PATCH /api/todos/{id}/complete
{
  "is_completed": true
}
```

**クエリパラメータ設計の思考**:

フィルタリング機能の要件から、以下のクエリパラメータが必要だとわかります：

```
要件: 「完了/未完了でフィルタリング」
  → ?status=completed | incomplete | all

要件: 「カテゴリー別でフィルタリング」
  → ?category={category_id}

要件: 「優先度別でフィルタリング」
  → ?priority=high | medium | low

要件: 「期限日でソート」
  → ?sort=due_date&order=asc | desc
```

**思考のポイント**:

- URLは「何を操作するか」を明確に
- HTTPメソッドは標準的な意味で使う
- クエリパラメータで柔軟な検索・フィルタを実現

#### 📝 補足

**認証とセキュリティ**:

全てのAPIエンドポイント（/api/auth を除く）は認証が必要です。

```
Authorization: Bearer {JWT_TOKEN}
```

各エンドポイントで、リクエストユーザーが操作対象のリソースの所有者かをチェックします：

```java
// 例: Todo取得時
Todo todo = todoRepository.findById(todoId)
    .orElseThrow(() -> new ResourceNotFoundException("Todo not found"));
if (!todo.getUserId().equals(currentUser.getId())) {
    throw new ForbiddenException("Forbidden");
}
```

### 8. UI/UX要件の整理 - 使いやすさの設計

#### 🎯 目的

データとAPIが決まったので、最後に「どう見せるか」「どう操作させるか」を設計します。

#### 🛠️ 手順詳細

画面構成を以下のように整理しました：

**基本レイアウト**:

```
+------------------+
| Header           | ← ロゴ、ユーザー情報、ログアウト
+------+-----------+
| Side | Main      | ← サイドバー + メインコンテンツ
| bar  | Content   |
+------+-----------+
```

**主要画面**:

1. **ログイン/登録画面**
   - シンプルなフォーム
   - メールアドレス、パスワード入力

2. **Todo一覧画面**
   - Todoカード/リスト形式
   - フィルター・ソート・検索バー
   - 「新規作成」ボタン

3. **Todo作成/編集画面**
   - モーダルダイアログ
   - フォーム項目（タイトル、説明、期限日、優先度、カテゴリー）

4. **可視化画面（Phase 2-3）**
   - 日付選択
   - グラフエリア（24時間積み上げ棒グラフなど）
   - 統計サマリー

#### 💡 理解ポイント

**UI設計で考慮すべきポイント**:

1. **認知的負荷の軽減**
   - よく使う操作は目立つ場所に
   - 「新規作成」ボタンは右上など定位置に

2. **フィードバックの即時性**
   - チェックボックスをクリック → 即座に完了状態に
   - ローディング中はスピナー表示

3. **エラーハンドリング**
   - フォーム入力ミス → 赤字でエラーメッセージ
   - サーバーエラー → ユーザーフレンドリーなメッセージ

4. **レスポンシブデザイン**
   - モバイル: サイドバーをハンバーガーメニューに
   - タブレット: グリッド表示を調整
   - デスクトップ: 広い画面を活かしたレイアウト

**可視化の設計（Phase 2-3）**:

要件「24時間の積み上げ棒グラフで、時系列とカテゴリー別を切り替え」から、以下のUI要素が必要：

```
[日付選択: 2025-12-14 ▼]  [表示切り替え: ●時系列順 ○カテゴリー別]

┌─────────────────────────────────────────┐
│  24時間の過ごし方                        │
│                                         │
│  ▓▓▓▓▓▓▓▓░░░░▓▓▓▓░░░░░░▓▓▓▓▓▓▓▓▓▓     │
│  0   6   12  18  24 (時)               │
│                                         │
│  ■ 仕事 (5h)  ■ 勉強 (3h)  ■ 趣味 (2h) │
└─────────────────────────────────────────┘
```

**思考のポイント**:

- ユーザーの操作フローを想像する
- 「最小クリック数」で目的を達成できるか
- モバイルでも使いやすいか

#### 📝 補足

**アクセシビリティ**:

余裕があれば以下も考慮します：

- キーボードナビゲーション（Tabキーで移動）
- スクリーンリーダー対応（適切なARIA属性）
- 色覚多様性への配慮（色だけで情報を伝えない）

### 9. 非機能要件の整理 - システムの品質を定義

#### 🎯 目的

「何ができるか」（機能要件）だけでなく、「どれくらい速く、安全に、保守しやすく作るか」（非機能要件）を明確にします。

#### 🛠️ 手順詳細

以下のカテゴリで非機能要件を整理しました：

**セキュリティ**:

- パスワードはハッシュ化（BCryptPasswordEncoder）して保存
- JWTトークンによる認証（Spring Security）
- SQLインジェクション対策（JPAの適切な使用）
- XSS対策（入力のサニタイゼーション）
- CSRF対策
- HTTPS通信（本番環境）

**パフォーマンス**:

- APIレスポンス時間: 平均500ms以下
- ページロード時間: 3秒以内
- データベースクエリの最適化（インデックス設定）

**可用性**:

- エラーハンドリング（適切なエラーメッセージ）
- サーバーエラー時のフォールバック

**保守性**:

- コードの可読性
- 適切なコメント
- READMEドキュメント
- API ドキュメント（Swagger / OpenAPI）

**拡張性**:

- 将来的な機能追加に対応できる柔軟なデータモデル
- マイクロサービス化を見据えた設計

#### 💡 理解ポイント

**非機能要件はなぜ重要か？**

機能要件だけ満たしても、以下の問題が起きる可能性があります：

- セキュリティが甘い → 情報漏洩
- パフォーマンスが悪い → ユーザー離れ
- 保守性が低い → バグ修正が困難、新機能追加が難しい

**数値目標の設定**:

「速い」「安全」だけでは曖昧なので、測定可能な目標を設定します：

```
× 「APIを速くする」
○ 「APIレスポンス時間を平均500ms以下にする」

× 「セキュアにする」
○ 「パスワードをbcryptでハッシュ化し、JWTトークンで認証する」
```

**思考のポイント**:

- 「-ility」で終わる言葉に注目（Security, Reliability, Scalability, Maintainability）
- プロジェクトの規模や目的に応じて優先順位を変える
- 個人開発なら「保守性」重視、エンタープライズなら「セキュリティ」「可用性」重視

#### 📝 補足

**MVPでは非機能要件をどこまで実装するか？**

Phase 1（MVP）でも、セキュリティは最初から考慮します。

```
Phase 1から実装:
  ✓ パスワードのハッシュ化
  ✓ JWT認証
  ✓ 基本的なバリデーション

Phase 2以降で強化:
  - レート制限（API叩きすぎ防止）
  - 詳細なログ記録
  - パフォーマンスモニタリング
```

「後から追加しにくいもの」は最初から入れる、というのが鉄則です。

### 10. 要件定義書の作成 - 全てを一つのドキュメントに

#### 🎯 目的

ここまで整理した内容を、一つの要件定義書にまとめます。このドキュメントが、開発の羅針盤になります。

#### 🛠️ 手順詳細

以下の構成で要件定義書を作成しました：

```markdown
# Todoアプリ 要件定義書

1. プロジェクト概要
   - 目的
   - 対象ユーザー

2. 技術スタック
   - フロントエンド、バックエンド、データベース

3. 機能要件
   - Phase 1: MVP
   - Phase 2: 時間管理機能
   - Phase 3: 高度な機能

4. データモデル設計
   - 各テーブルの定義

5. API設計概要
   - エンドポイント一覧

6. UI/UX要件
   - 画面構成、レイアウト

7. 非機能要件
   - セキュリティ、パフォーマンス、保守性など

8. 開発方針
   - 開発順序、プロセス、テスト方針

9. 将来的な拡張案
```

#### 💡 理解ポイント

**要件定義書の役割**:

1. **開発者への指示書**
   - 何を作るかが明確
   - 迷ったらこのドキュメントに戻る

2. **ユーザーとの合意文書**
   - 「これで合ってますか？」の確認
   - スコープの明確化

3. **進捗管理のチェックリスト**
   - Phase 1の機能を全て実装したか確認
   - チェックボックス（- [ ]）で管理

4. **将来の自分への記録**
   - 「なぜこの設計にしたのか？」を思い出せる
   - 引き継ぎ資料にもなる

**良い要件定義書の条件**:

1. **具体的**: 「良いUI」ではなく「レスポンシブデザイン対応」
2. **測定可能**: 「速い」ではなく「平均500ms以下」
3. **実現可能**: 技術的に実装できる内容
4. **関連性**: プロジェクトの目的に沿っている
5. **期限付き**: Phase 1, 2, 3 と段階を区切る（SMART原則）

**思考のポイント**:

- 読み手（将来の自分、他の開発者）を意識
- 専門用語を使いすぎない（または説明を添える）
- 図やコード例を入れて理解しやすく

#### 📝 補足

**要件定義書は「生きたドキュメント」**:

開発中に新しい気づきがあれば、要件定義書を更新します。

```
初版: 2025-12-14
更新: 2025-12-20 - Phase 1実装中に「パスワードリセット機能」が必要と判明、追加
更新: 2025-12-25 - ユーザーフィードバックを受けて「ダークモード」を Phase 3 に追加
```

「一度作ったら終わり」ではなく、プロジェクトと共に進化させます。

## 学び・次に活かせる知見

### 要件定義の鉄則

1. **段階的な質問で要求を引き出す**
   - いきなり全てを聞かない
   - 「プラットフォーム → データ → 機能 → 詳細」と絞り込む
   - 選択肢を提示して、ユーザーの判断を助ける

2. **「その他」の回答に真の価値がある**
   - 選択肢はあくまで「よくあるパターン」
   - ユーザーの独自要求は「その他」で出てくることが多い
   - それがアプリの差別化要因になる

3. **曖昧な要求は必ず深掘りする**
   - 「可視化したい」だけでは不十分
   - 「何を？どう？いつ？」と具体化する
   - 実装可能なレベルまで落とし込む

4. **優先順位は必ず決める**
   - 全ての機能を同時に作ることは不可能
   - MVP → コア機能 → 付加価値 の順で段階化
   - ユーザーに「MVP最優先」を選んでもらうことが重要

5. **技術的制約は早めに共有する**
   - 「それは実装が難しい」は早めに伝える
   - 代替案を提示する
   - ユーザーの期待値を適切に管理

### データモデル設計の思考法

1. **要件から名詞と動詞を抽出する**
   - 名詞 → テーブル（User, Todo, Category）
   - 動詞 → テーブルまたはフィールド（「時間を記録する」 → TimeEntry）

2. **関係性を図示する**
   - 1対多、多対多を見極める
   - 外部キー、中間テーブルの必要性を判断

3. **制約を明確にする**
   - NOT NULL, UNIQUE, DEFAULT などの制約
   - バリデーションルールの定義

4. **将来の拡張を見据える**
   - 「今は使わないけど、将来便利そう」なフィールドは入れておく
   - 例: Category の color フィールド

### API設計の原則

1. **RESTful設計の原則に従う**
   - リソース指向のURL
   - HTTPメソッドの標準的な使い方

2. **クエリパラメータで柔軟性を持たせる**
   - フィルタリング、ソート、ページネーションなど
   - 1つのエンドポイントで複数のユースケースに対応

3. **バージョニングを考慮する**
   - 将来的な変更に備えて `/api/v1/todos` のようにバージョンを入れる

### ドキュメント作成のコツ

1. **チェックボックスを活用する**
   - 進捗管理がしやすい
   - 達成感が得られる

2. **コード例を入れる**
   - データモデル、API仕様は擬似コードで示す
   - 理解が早く、実装時の参考になる

3. **図を使う**
   - ER図、画面遷移図、シーケンス図など
   - 言葉だけでは伝わりにくい構造を視覚化

4. **更新履歴を残す**
   - いつ、何を、なぜ変更したかを記録
   - 意思決定の経緯がわかる

## 参考文献

1. [Spring Boot公式ドキュメント](https://spring.io/projects/spring-boot)
2. [PostgreSQL公式ドキュメント](https://www.postgresql.org/docs/)
3. [RESTful API設計のベストプラクティス](https://restfulapi.net/)
4. [データベース設計の基礎](https://www.amazon.co.jp/dp/4798161684)
5. [要件定義のチェックリスト（IPA）](https://www.ipa.go.jp/sec/reports/20060424.html)

---

**作成日**: 2025-12-14
**最終更新**: 2025-12-14
